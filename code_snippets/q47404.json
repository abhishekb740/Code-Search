{
    "title": "How do I avoid checking for nulls in Java?",
    "description": [
        "I use x != null to avoid NullPointerException. Is there an alternative?",
        "if (x != null) {",
        "    // ...",
        "}"
    ],
    "answer": [
        "This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don't know or don't trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.",
        "To put this another way, there are two instances where null checking comes up:",
        "Where null is a valid response in terms of the contract; and",
        "Where it isn't a valid response.",
        "(2) is easy.  As of Java 1.7 you can use Objects.requireNonNull(foo). (If you are stuck with a previous version then assertions may be a good alternative.)",
        "\"Proper\" usage of this method would be like below. The method returns the object passed into it and throws a NullPointerException if the object is null. This means that the returned value is always non-null. The method is primarily intended for validating parameters.",
        "public Foo(Bar bar) {",
        "    this.bar = Objects.requireNonNull(bar);",
        "}",
        "It can also be used like an assertion though since it throws an exception if the object is null. In both uses, a message can be added which will be shown in the exception. Below is using it like an assertion and providing a message.",
        "Objects.requireNonNull(someobject, \"if someobject is null then something is wrong\");",
        "someobject.doCalc();",
        "Generally throwing a specific exception like NullPointerException when a value is null but shouldn't be is favorable to throwing a more general exception like AssertionError. This is the approach the Java library takes; favoring NullPointerException over IllegalArgumentException when an argument is not allowed to be null.",
        "(1) is a little harder.  If you have no control over the code you're calling then you're stuck.  If null is a valid response, you have to check for it.",
        "If it's code that you do control, however (and this is often the case), then it's a different story.  Avoid using nulls as a response.  With methods that return collections, it's easy: return empty collections (or arrays) instead of nulls pretty much all the time.",
        "With non-collections it might be harder.  Consider this as an example: if you have these interfaces:",
        "public interface Action {",
        "  void doSomething();",
        "}",
        "public interface Parser {",
        "  Action findAction(String userInput);",
        "}",
        "where Parser takes raw user input and finds something to do, perhaps if you're implementing a command line interface for something.  Now you might make the contract that it returns null if there's no appropriate action.  That leads the null checking you're talking about.",
        "An alternative solution is to never return null and instead use the Null Object pattern:",
        "public class MyParser implements Parser {",
        "  private static Action DO_NOTHING = new Action() {",
        "    public void doSomething() { /* do nothing */ }",
        "  };",
        "  public Action findAction(String userInput) {",
        "    // ...",
        "    if ( /* we can't find any actions */ ) {",
        "      return DO_NOTHING;",
        "    }",
        "  }",
        "}",
        "Compare:",
        "Parser parser = ParserFactory.getParser();",
        "if (parser == null) {",
        "  // now what?",
        "  // this would be an example of where null isn't (or shouldn't be) a valid response",
        "}",
        "Action action = parser.findAction(someInput);",
        "if (action == null) {",
        "  // do nothing",
        "} else {",
        "  action.doSomething();",
        "}",
        "to",
        "ParserFactory.getParser().findAction(someInput).doSomething();",
        "which is a much better design because it leads to more concise code.",
        "That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.",
        "try {",
        "    ParserFactory.getParser().findAction(someInput).doSomething();",
        "} catch(ActionNotFoundException anfe) {",
        "    userConsole.err(anfe.getMessage());",
        "}",
        "Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.",
        "public Action findAction(final String userInput) {",
        "    /* Code to return requested Action if found */",
        "    return new Action() {",
        "        public void doSomething() {",
        "            userConsole.err(\"Action not found: \" + userInput);",
        "        }",
        "    }",
        "}"
    ]
}